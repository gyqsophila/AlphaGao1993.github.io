<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"alphagao.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"hide","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="sync.Map 是在 Go 1.9 版本新增的并发安全的 map 类型。我们知道通过将普通的 map 与 sync.Mutex 或 sync.RWMutex 结合也能实现并发安全的 map 结构，那为什么 Go 还要提供新的 sync.Map类型呢，又与结合 Mutex 的 map 有什么区别呢？一起来看下吧。">
<meta property="og:type" content="article">
<meta property="og:title" content="Go 中 map 与 sync.Map 性能比较">
<meta property="og:url" content="https://alphagao.com/2025/09/09/go-sync-map-and-map/index.html">
<meta property="og:site_name" content="AlphaGao&#39;s Blog">
<meta property="og:description" content="sync.Map 是在 Go 1.9 版本新增的并发安全的 map 类型。我们知道通过将普通的 map 与 sync.Mutex 或 sync.RWMutex 结合也能实现并发安全的 map 结构，那为什么 Go 还要提供新的 sync.Map类型呢，又与结合 Mutex 的 map 有什么区别呢？一起来看下吧。">
<meta property="og:locale">
<meta property="article:published_time" content="2025-09-09T07:57:28.000Z">
<meta property="article:modified_time" content="2025-09-10T02:54:13.443Z">
<meta property="article:author" content="Alpha Gao">
<meta property="article:tag" content="map">
<meta property="article:tag" content="sync">
<meta property="article:tag" content="RWMutex">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://alphagao.com/2025/09/09/go-sync-map-and-map/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-Hans'
  };
</script>

  <title>Go 中 map 与 sync.Map 性能比较 | AlphaGao's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">AlphaGao's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">恐惧源于火力不足，紧张源于准备不足！</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://alphagao.com/2025/09/09/go-sync-map-and-map/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Alpha Gao">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="AlphaGao's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Go 中 map 与 sync.Map 性能比较
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-09-09 15:57:28" itemprop="dateCreated datePublished" datetime="2025-09-09T15:57:28+08:00">2025-09-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-09-10 10:54:13" itemprop="dateModified" datetime="2025-09-10T10:54:13+08:00">2025-09-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Go/" itemprop="url" rel="index"><span itemprop="name">Go</span></a>
                </span>
            </span>

          
            <span id="/2025/09/09/go-sync-map-and-map/" class="post-meta-item leancloud_visitors" data-flag-title="Go 中 map 与 sync.Map 性能比较" title="Views">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2025/09/09/go-sync-map-and-map/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2025/09/09/go-sync-map-and-map/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p><code>sync.Map</code> 是在 Go 1.9 版本新增的并发安全的 map 类型。我们知道通过将普通的 <code>map</code> 与 <code>sync.Mutex</code> 或 <code>sync.RWMutex</code> 结合也能实现并发安全的 map 结构，那为什么 Go 还要提供新的 <code>sync.Map</code>类型呢，又与结合 <code>Mutex</code> 的 <code>map</code> 有什么区别呢？一起来看下吧。</p>
<span id="more"></span>
<h3 id="sync-Map-源码分析"><a href="#sync-Map-源码分析" class="headerlink" title="sync.Map 源码分析"></a><code>sync.Map</code> 源码分析</h3><p>一个标准的 <code>sync.Map</code> 的内部结构为：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Map <span class="keyword">struct</span> &#123;</span><br><span class="line">	mu Mutex</span><br><span class="line"></span><br><span class="line">	<span class="comment">// read contains the portion of the map&#x27;s contents that are safe for</span></span><br><span class="line">	<span class="comment">// concurrent access (with or without mu held).</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// The read field itself is always safe to load, but must only be stored with</span></span><br><span class="line">	<span class="comment">// mu held.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Entries stored in read may be updated concurrently without mu, but updating</span></span><br><span class="line">	<span class="comment">// a previously-expunged `entry` requires that the `entry` be copied to the dirty</span></span><br><span class="line">	<span class="comment">// map and unexpunged with mu held.</span></span><br><span class="line">	read atomic.Pointer[readOnly]</span><br><span class="line"></span><br><span class="line">	<span class="comment">// dirty contains the portion of the map&#x27;s contents that require mu to be</span></span><br><span class="line">	<span class="comment">// held. To ensure that the dirty map can be promoted to the read map quickly,</span></span><br><span class="line">	<span class="comment">// it also includes all of the non-expunged entries in the read map.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Expunged entries are not stored in the dirty map. An expunged `entry` in the</span></span><br><span class="line">	<span class="comment">// clean map must be unexpunged and added to the dirty map before a new value</span></span><br><span class="line">	<span class="comment">// can be stored to it.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// If the dirty map is nil, the next write to the map will initialize it by</span></span><br><span class="line">	<span class="comment">// making a shallow copy of the clean map, omitting stale entries.</span></span><br><span class="line">	dirty <span class="keyword">map</span>[any]*entry</span><br><span class="line"></span><br><span class="line">	<span class="comment">// misses counts the number of loads since the read map was last updated that</span></span><br><span class="line">	<span class="comment">// needed to lock mu to determine whether the key was present.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Once enough misses have occurred to cover the cost of copying the dirty</span></span><br><span class="line">	<span class="comment">// map, the dirty map will be promoted to the read map (in the unamended</span></span><br><span class="line">	<span class="comment">// state) and the next store to the map will make a new dirty copy.</span></span><br><span class="line">	misses <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>可以看到 <code>sync.Map</code> 内部也是使用了一个 <code>Mutex</code> 互斥锁，与此同还有其他几个属性。</p>
<p><strong>read</strong></p>
<p><code>read</code> 是仅用于并发读取的只读快照，无论是否持有锁，该结构的读取都是并发安全的。但更新操作就必须持有 <code>mu</code> 这个锁才能继续。这里也许你会觉得前后注释冲突，明明说更新 <code>read</code> 需要持有 <code>mu</code> ，但是又说可以在不持有锁的情况下并发修改。但其实这里的更新操作是将 <code>dirty</code> 升级为 <code>read</code>，而不是更新 <code>read</code> 里的某条 <code>entry</code>，修改某一条 <code>entry</code> 通过原子操作就能实现不持有锁还能保证并发安全。</p>
<p>然后如果 <code>read</code> 中有一条 <code>entry</code> 被标记删除了，后面还要继续修改这条 <code>entry</code> 的值就得持有锁，并且将该条 <code>entry</code> 移到 <code>dirty</code> 中，再写入新值。例如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">m := sync.Map&#123;&#125;</span><br><span class="line">m.Store(<span class="string">&quot;foo&quot;</span>, <span class="number">1</span>)</span><br><span class="line">m.Delete(<span class="string">&quot;foo&quot;</span>) <span class="comment">// foo 被 expunge 了</span></span><br><span class="line">m.Store(<span class="string">&quot;foo&quot;</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>第一次 <code>Store(&quot;foo&quot;, 1)</code> → 写入 <code>read</code>。</li>
<li><code>Delete(&quot;foo&quot;)</code> → foo 被标记为 expunged。</li>
<li>再次 <code>Store(&quot;foo&quot;, 2)</code> → 由于 foo 已被 expunge，不能直接更新 <code>read</code>，<br>必须加锁，把 foo 移到 <code>dirty</code> 并取消删除状态，然后写入新值。此时这条 <code>entry</code> 在 <code>dirty</code> 中而不在 <code>read</code> 中。</li>
</ul>
<p><strong>dirty</strong></p>
<p><code>dirty</code> 是用于存储新写入的 <code>entry</code>，也就是此前不存在于 <code>read</code> 中的，因为如果已在 <code>read</code> 中的 <code>entry</code> 的更新是可以直接无锁操作的。同时为了保证 <code>dirty</code> 能够快速升级为 <code>read</code>，在 <code>dirty</code> 初始化的时候就将 <code>read</code> 的内容写入到 <code>dirty</code> 中。但我并没有在 <code>Store</code> 方法的源码中看到有同时写入 <code>dirty</code> 的逻辑，那是因为 <code>entry</code> 的结构如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// An `entry` is a slot in the map corresponding to a particular key.</span></span><br><span class="line"><span class="keyword">type</span> <span class="string">`entry`</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// p points to the interface&#123;&#125; value stored for the `entry`.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// If p == nil, the `entry` has been deleted, and either m.dirty == nil or</span></span><br><span class="line">	<span class="comment">// m.dirty[key] is e.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// If p == expunged, the `entry` has been deleted, m.dirty != nil, and the `entry`</span></span><br><span class="line">	<span class="comment">// is missing from m.dirty.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Otherwise, the `entry` is valid and recorded in m.read.m[key] and, if m.dirty</span></span><br><span class="line">	<span class="comment">// != nil, in m.dirty[key].</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// An `entry` can be deleted by atomic replacement with nil: when m.dirty is</span></span><br><span class="line">	<span class="comment">// next created, it will atomically replace nil with expunged and leave</span></span><br><span class="line">	<span class="comment">// m.dirty[key] unset.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// An `entry`&#x27;s associated value can be updated by atomic replacement, provided</span></span><br><span class="line">	<span class="comment">// p != expunged. If p == expunged, an `entry`&#x27;s associated value can be updated</span></span><br><span class="line">	<span class="comment">// only after first setting m.dirty[key] = e so that lookups using the dirty</span></span><br><span class="line">	<span class="comment">// map find the `entry`.</span></span><br><span class="line">	p atomic.Pointer[any]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>entry</code> 实际上是个带类型的指针容器，而 <code>dirty</code> 在初始化的时候逻辑为：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> dirtyLocked() &#123;</span><br><span class="line">	<span class="keyword">if</span> m.dirty != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	read := m.loadReadOnly()</span><br><span class="line">	m.dirty = <span class="built_in">make</span>(<span class="keyword">map</span>[any]*entry, <span class="built_in">len</span>(read.m))</span><br><span class="line">	<span class="keyword">for</span> k, e := <span class="keyword">range</span> read.m &#123;</span><br><span class="line">		<span class="keyword">if</span> !e.tryExpungeLocked() &#123;</span><br><span class="line">			m.dirty[k] = e</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单来说，就是将 <code>read</code> 的值遍历后放进 <code>dirty</code>，而因为 <code>entry</code> 是指针结构，因此在更新 <code>read</code> 的时候，<code>dirty</code> 中也会同步更新。当需删除某条 <code>entry</code> 的时候，会直接将该条 <code>entry</code> 从 <code>dirty</code> 中删除，但对于 <code>read</code> 就只是标记删除：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> LoadAndDelete(key any) (value any, loaded <span class="type">bool</span>) &#123;</span><br><span class="line">	read := m.loadReadOnly()</span><br><span class="line">	e, ok := read.m[key]</span><br><span class="line">	<span class="keyword">if</span> !ok &amp;&amp; read.amended &#123;</span><br><span class="line">		m.mu.Lock()</span><br><span class="line">		read = m.loadReadOnly()</span><br><span class="line">		e, ok = read.m[key]</span><br><span class="line">		<span class="keyword">if</span> !ok &amp;&amp; read.amended &#123;</span><br><span class="line">			e, ok = m.dirty[key]</span><br><span class="line">			<span class="built_in">delete</span>(m.dirty, key)</span><br><span class="line">			<span class="comment">// Regardless of whether the `entry` was present, record a miss: this key</span></span><br><span class="line">			<span class="comment">// will take the slow path until the dirty map is promoted to the read</span></span><br><span class="line">			<span class="comment">// map.</span></span><br><span class="line">			m.missLocked()</span><br><span class="line">		&#125;</span><br><span class="line">		m.mu.Unlock()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> ok &#123;</span><br><span class="line">		<span class="keyword">return</span> e.<span class="built_in">delete</span>()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果 <code>dirty</code> 是 nil，那么在下一次写操作的时候，会通过 <code>read</code> 的浅拷贝来初始化 <code>dirty</code>，此浅拷不会将标记删除的 <code>entry</code> 放进 <code>dirty</code> 中。</p>
<p><strong>misses</strong></p>
<p><code>misses</code> 是一个计数器，统计从 <code>read</code> 上一次更新以来，也就是从 <code>dirty</code> 升级到 <code>read</code>，查询 <code>read</code> 没有命中的次数，如没有命中 <code>read</code>，就会加锁去 <code>dirty</code> 中查询，这就是一次 miss。当 miss 次数达一定量，就会触发 <code>dirty</code> 到 <code>read</code> 的升级。这样可以避免频繁的持有 <code>mu</code> 去查询 <code>dirty</code>，又能避免每次有新的 <code>entry</code> 就立刻将 <code>dirty</code> 升级为 <code>read</code> 带来的性能开销。</p>
<p>那么具体 <code>misses</code> 到多少的时候会触发 <code>dirty</code> 升级为 <code>read</code> 呢？通过 <code>missLocked</code> 方法可以看到：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> missLocked() &#123;</span><br><span class="line">	m.misses++</span><br><span class="line">	<span class="keyword">if</span> m.misses &lt; <span class="built_in">len</span>(m.dirty) &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	m.read.Store(&amp;readOnly&#123;m: m.dirty&#125;)</span><br><span class="line">	m.dirty = <span class="literal">nil</span></span><br><span class="line">	m.misses = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>当 <code>misses</code> 的值等于 <code>dirty</code> 的数量的时候，就会触发 <code>dirty</code> 升级为 <code>read</code>，然后 <code>misses</code> 归零。</p>
<p>总结一下，<code>sync.Map</code> 内部有 <code>read</code> 和 <code>dirty</code> 2 个存储结构，<code>read</code> 用于只读查询，并且查询操作是不带锁的，这样查比加了锁的普通 map 更快。而如果没有命中 <code>read</code> 存储，就会加锁查询 <code>dirty</code>，并标记一次 miss。每次新增加的 <code>entry</code> 会直接写入到 <code>dirty</code>。当写入的新 <code>entry</code> 的数量和 miss 的数量相等，就会触发 <code>dirty</code> 升级为 <code>read</code>。很明显升级的开销是比较大的，因此写多读少的场景是不适合 <code>sync.Map</code> 的，因为可能会频繁触发 <code>dirty</code> 升级为 <code>read</code>。</p>
<p>此时再回头看官网文档里说的：</p>
<blockquote>
<p>The Map type is optimized for two common use cases: (1) when the <code>entry</code> for a given key is only ever written once but read many times, as in caches that only grow, or (2) when multiple goroutines read, write, and overwrite entries for disjoint sets of keys. In these two cases, use of a Map may significantly reduce lock contention compared to a Go map paired with a separate Mutex or RWMutex.</p>
</blockquote>
<p><code>sync.Map</code> 只适用 2 个场景：</p>
<p>一、每个 <code>entry</code> 仅写入一次，之后就是大量的读，此时的 <code>sync.Map</code> 其实就是充当缓存的作用。</p>
<ul>
<li>这种场景下 <code>entry</code> 一旦写入就会立刻触发 <code>dirty</code> 升级写入到 <code>read</code> 中，之后的查询都是无锁操作，性能会非常高</li>
</ul>
<p>二、多个 goroutine 读写操作，但操作的是不相交的 key 集合</p>
<ul>
<li>这个场景下，因为每个 goroutine 操作的 key 不相同，不会产生激烈的锁竞争，read + dirty 的机制的优势同样能够发挥出来。</li>
</ul>
<h3 id="sync-Map-与-map-sync-RWMutex-性能差异"><a href="#sync-Map-与-map-sync-RWMutex-性能差异" class="headerlink" title="sync.Map 与 map+sync.RWMutex 性能差异"></a>sync.Map 与 map+sync.RWMutex 性能差异</h3><p>与 <code>sync.Map</code> 的 <code>read</code> + <code>dirty</code> 机制下的查询几乎无锁操作相比，<code>map</code> + <code>sync.RWMutex</code> 的形式，读写都要抢同一个锁，在高并发下很容易成为性能瓶颈。那么我们就来看看二者之间的性能差异到底有多大。</p>
<p>通过 Go 的 benchmark，我们能够轻易得到 2 种 map 的性能差异：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;strconv&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;sync/atomic&quot;</span></span><br><span class="line">	<span class="string">&quot;testing&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====== 基于 RWMutex 的并发 map ======</span></span><br><span class="line"><span class="keyword">type</span> RWMap <span class="keyword">struct</span> &#123;</span><br><span class="line">	mu sync.RWMutex</span><br><span class="line">	m  <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewRWMap</span><span class="params">()</span></span> *RWMap &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;RWMap&#123;m: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>)&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rm *RWMap)</span></span> Load(key <span class="type">string</span>) (<span class="type">string</span>, <span class="type">bool</span>) &#123;</span><br><span class="line">	rm.mu.RLock()</span><br><span class="line">	<span class="keyword">defer</span> rm.mu.RUnlock()</span><br><span class="line">	v, ok := rm.m[key]</span><br><span class="line">	<span class="keyword">return</span> v, ok</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rm *RWMap)</span></span> Store(key, value <span class="type">string</span>) &#123;</span><br><span class="line">	rm.mu.Lock()</span><br><span class="line">	<span class="keyword">defer</span> rm.mu.Unlock()</span><br><span class="line">	rm.m[key] = value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====== 测试函数（传入读写比例） ======</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">benchmarkRWMap</span><span class="params">(b *testing.B, writePercent <span class="type">int</span>, keyRange <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	rm := NewRWMap()</span><br><span class="line">	<span class="keyword">var</span> reads, writes <span class="type">int64</span></span><br><span class="line"></span><br><span class="line">	b.ResetTimer()</span><br><span class="line">	b.RunParallel(<span class="function"><span class="keyword">func</span><span class="params">(pb *testing.PB)</span></span> &#123;</span><br><span class="line">		i := <span class="number">0</span></span><br><span class="line">		<span class="keyword">for</span> pb.Next() &#123;</span><br><span class="line">			key := strconv.Itoa(i % keyRange)</span><br><span class="line">			<span class="keyword">if</span> i%<span class="number">100</span> &lt; writePercent &#123; <span class="comment">// 按比例写</span></span><br><span class="line">				rm.Store(key, <span class="string">&quot;value&quot;</span>)</span><br><span class="line">				atomic.AddInt64(&amp;writes, <span class="number">1</span>)</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				rm.Load(key)</span><br><span class="line">				atomic.AddInt64(&amp;reads, <span class="number">1</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			i++</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line">	b.ReportMetric(<span class="type">float64</span>(reads), <span class="string">&quot;reads&quot;</span>)</span><br><span class="line">	b.ReportMetric(<span class="type">float64</span>(writes), <span class="string">&quot;writes&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">benchmarkSyncMap</span><span class="params">(b *testing.B, writePercent <span class="type">int</span>, keyRange <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> sm sync.Map</span><br><span class="line">	<span class="keyword">var</span> reads, writes <span class="type">int64</span></span><br><span class="line"></span><br><span class="line">	b.ResetTimer()</span><br><span class="line">	b.RunParallel(<span class="function"><span class="keyword">func</span><span class="params">(pb *testing.PB)</span></span> &#123;</span><br><span class="line">		i := <span class="number">0</span></span><br><span class="line">		<span class="keyword">for</span> pb.Next() &#123;</span><br><span class="line">			key := strconv.Itoa(i % keyRange)</span><br><span class="line">			<span class="keyword">if</span> i%<span class="number">100</span> &lt; writePercent &#123; <span class="comment">// 按比例写</span></span><br><span class="line">				sm.Store(key, <span class="string">&quot;value&quot;</span>)</span><br><span class="line">				atomic.AddInt64(&amp;writes, <span class="number">1</span>)</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				sm.Load(key)</span><br><span class="line">				atomic.AddInt64(&amp;reads, <span class="number">1</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			i++</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line">	b.ReportMetric(<span class="type">float64</span>(reads), <span class="string">&quot;reads&quot;</span>)</span><br><span class="line">	b.ReportMetric(<span class="type">float64</span>(writes), <span class="string">&quot;writes&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====== 不同比例测试 ======</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkCompare</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	proportions := []<span class="type">int</span>&#123;<span class="number">10</span>, <span class="number">50</span>, <span class="number">90</span>&#125; <span class="comment">// 写占比（%）</span></span><br><span class="line">	keyRanges := []<span class="type">int</span>&#123;<span class="number">1_000</span>, <span class="number">10_1000</span>, <span class="number">100_000</span>, <span class="number">1_000_000</span>&#125;</span><br><span class="line">	<span class="keyword">for</span> _, keyRange := <span class="keyword">range</span> keyRanges &#123;</span><br><span class="line">		<span class="keyword">for</span> _, p := <span class="keyword">range</span> proportions &#123;</span><br><span class="line">			b.Run(fmt.Sprintf(<span class="string">&quot;RWMap_Write%d%%&quot;</span>, p), <span class="function"><span class="keyword">func</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">				benchmarkRWMap(b, p, keyRange)</span><br><span class="line">			&#125;)</span><br><span class="line">			b.Run(fmt.Sprintf(<span class="string">&quot;SyncMap_Write%d%%&quot;</span>, p), <span class="function"><span class="keyword">func</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">				benchmarkSyncMap(b, p, keyRange)</span><br><span class="line">			&#125;)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我分别在 key 的数量规模在 1k、1w、10w 和 100w 的级别下，再对分别写操作占比 10%、50%、90% 的场景下跑性能测试，得到以下结果。</p>
<p>首先来看 key 数量级为 1000 的情况：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">goos: darwin</span><br><span class="line">goarch: amd64</span><br><span class="line">pkg: github.com/alphagao1993/hello-<span class="keyword">go</span>/<span class="keyword">map</span></span><br><span class="line">cpu: Intel(R) Core(TM) i7<span class="number">-8850</span>H CPU @ <span class="number">2.60</span>GHz</span><br><span class="line">BenchmarkCompare/RWMap_1000_Write10%<span class="number">-12</span>         	 <span class="number">6669214</span>	       <span class="number">178.9</span> ns/op	   <span class="number">6002244</span> reads	    <span class="number">666970</span> writes	       <span class="number">2</span> B/op	       <span class="number">0</span> allocs/op</span><br><span class="line">BenchmarkCompare/SyncMap_1000_Write10%<span class="number">-12</span>       	<span class="number">53742982</span>	        <span class="number">29.23</span> ns/op	  <span class="number">48368622</span> reads	   <span class="number">5374360</span> writes	       <span class="number">6</span> B/op	       <span class="number">1</span> allocs/op</span><br><span class="line">BenchmarkCompare/RWMap_1000_Write50%<span class="number">-12</span>         	 <span class="number">4398858</span>	       <span class="number">286.9</span> ns/op	   <span class="number">2199266</span> reads	   <span class="number">2199592</span> writes	       <span class="number">2</span> B/op	       <span class="number">0</span> allocs/op</span><br><span class="line">BenchmarkCompare/SyncMap_1000_Write50%<span class="number">-12</span>       	<span class="number">36015285</span>	        <span class="number">35.23</span> ns/op	  <span class="number">18007510</span> reads	  <span class="number">18007775</span> writes	      <span class="number">18</span> B/op	       <span class="number">1</span> allocs/op</span><br><span class="line">BenchmarkCompare/RWMap_1000_Write90%<span class="number">-12</span>         	 <span class="number">6561000</span>	       <span class="number">174.8</span> ns/op	    <span class="number">656044</span> reads	   <span class="number">5904956</span> writes	       <span class="number">2</span> B/op	       <span class="number">0</span> allocs/op</span><br><span class="line">BenchmarkCompare/SyncMap_1000_Write90%<span class="number">-12</span>       	<span class="number">27884427</span>	        <span class="number">48.76</span> ns/op	   <span class="number">2788395</span> reads	  <span class="number">25096032</span> writes	      <span class="number">31</span> B/op	       <span class="number">2</span> allocs/op</span><br></pre></td></tr></table></figure>
<p>在写比例 10% 的场景下，<code>RWMap</code> 每次操作的平耗时为 178.9ns，申请内存次为 0，而 <code>sync.Map</code> 的平均操时间是 29.23ns，是 <code>RWMap</code> 的 1/6，平均申请内存 1 次；<br>在写比例 50% 的场景下，<code>RWMap</code> 每次操作的平耗时为 286.9ns，申请内存次为 0，而 <code>sync.Map</code> 的平均操时间是 35.23ns，是 <code>RWMap</code> 的 1/8，平均申请内存 1 次；<br>在写比例 90% 的场景下，<code>RWMap</code> 每次操作的平耗时为 174.8ns，申请内存次为 0，而 <code>sync.Map</code> 的平均操时间是 48.76ns，是 <code>RWMap</code> 的 1/3，平均申请内存 2 次；</p>
<p>很明显看到，当写比例达到 90%，<code>sync.Map</code> 的性能出明显下降，几乎每次操作都要申请 2 次内存，但即便如此，<code>sync.Map</code> 的读写性能还是远快于 RWMap。</p>
<p>再来看 key 的数量为 1w 的场景：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">BenchmarkCompare/RWMap_10000_Write10%<span class="number">-12</span>        	 <span class="number">5330550</span>	       <span class="number">214.9</span> ns/op	   <span class="number">4797432</span> reads	    <span class="number">533118</span> writes	       <span class="number">3</span> B/op	       <span class="number">0</span> allocs/op</span><br><span class="line">BenchmarkCompare/SyncMap_10000_Write10%<span class="number">-12</span>      	<span class="number">35376084</span>	        <span class="number">33.64</span> ns/op	  <span class="number">31838438</span> reads	   <span class="number">3537646</span> writes	       <span class="number">7</span> B/op	       <span class="number">1</span> allocs/op</span><br><span class="line">BenchmarkCompare/RWMap_10000_Write50%<span class="number">-12</span>        	 <span class="number">3341437</span>	       <span class="number">338.3</span> ns/op	   <span class="number">1670533</span> reads	   <span class="number">1670904</span> writes	       <span class="number">4</span> B/op	       <span class="number">0</span> allocs/op</span><br><span class="line">BenchmarkCompare/SyncMap_10000_Write50%<span class="number">-12</span>      	<span class="number">29461378</span>	        <span class="number">54.60</span> ns/op	  <span class="number">14730535</span> reads	  <span class="number">14730843</span> writes	      <span class="number">19</span> B/op	       <span class="number">1</span> allocs/op</span><br><span class="line">BenchmarkCompare/RWMap_10000_Write90%<span class="number">-12</span>        	 <span class="number">4815813</span>	       <span class="number">273.3</span> ns/op	    <span class="number">481526</span> reads	   <span class="number">4334287</span> writes	       <span class="number">4</span> B/op	       <span class="number">0</span> allocs/op</span><br><span class="line">BenchmarkCompare/SyncMap_10000_Write90%<span class="number">-12</span>      	<span class="number">18878964</span>	        <span class="number">64.24</span> ns/op	   <span class="number">1887857</span> reads	  <span class="number">16991107</span> writes	      <span class="number">32</span> B/op	       <span class="number">2</span> allocs/op</span><br></pre></td></tr></table></figure>
<p>还是能够看出随着写比例的上升，<code>sync.Map</code> 的性能有所下降，但仍然远快于 <code>RWMap</code>;</p>
<p>key 数量级为 10w 的场景：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">BenchmarkCompare/RWMap_100000_Write10%<span class="number">-12</span>       	 <span class="number">4503927</span>	       <span class="number">249.3</span> ns/op	   <span class="number">4053487</span> reads	    <span class="number">450440</span> writes	       <span class="number">5</span> B/op	       <span class="number">0</span> allocs/op</span><br><span class="line">BenchmarkCompare/SyncMap_100000_Write10%<span class="number">-12</span>     	<span class="number">25254602</span>	        <span class="number">43.32</span> ns/op	  <span class="number">22729090</span> reads	   <span class="number">2525512</span> writes	       <span class="number">9</span> B/op	       <span class="number">1</span> allocs/op</span><br><span class="line">BenchmarkCompare/RWMap_100000_Write50%<span class="number">-12</span>       	 <span class="number">3342763</span>	       <span class="number">324.0</span> ns/op	   <span class="number">1671284</span> reads	   <span class="number">1671479</span> writes	       <span class="number">6</span> B/op	       <span class="number">0</span> allocs/op</span><br><span class="line">BenchmarkCompare/SyncMap_100000_Write50%<span class="number">-12</span>     	<span class="number">17258281</span>	        <span class="number">59.10</span> ns/op	   <span class="number">8629031</span> reads	   <span class="number">8629250</span> writes	      <span class="number">22</span> B/op	       <span class="number">2</span> allocs/op</span><br><span class="line">BenchmarkCompare/RWMap_100000_Write90%<span class="number">-12</span>       	 <span class="number">4746644</span>	       <span class="number">236.0</span> ns/op	    <span class="number">474600</span> reads	   <span class="number">4272044</span> writes	       <span class="number">7</span> B/op	       <span class="number">0</span> allocs/op</span><br><span class="line">BenchmarkCompare/SyncMap_100000_Write90%<span class="number">-12</span>     	<span class="number">14010303</span>	        <span class="number">79.63</span> ns/op	   <span class="number">1400966</span> reads	  <span class="number">12609337</span> writes	      <span class="number">34</span> B/op	       <span class="number">2</span> allocs/op</span><br></pre></td></tr></table></figure><br>依然能够看到当写比上升， <code>sync.Map</code> 的性能在下降，但还是明显高于 <code>RWMap</code>，奇怪的是 <code>RWMap</code> 在写比例为 50% 的时候性能下降，但在写比例 90% 的时候又涨上去了，这有点特殊；</p>
<p>key 数量为 100w 的场景：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">BenchmarkCompare/RWMap_1000000_Write10%<span class="number">-12</span>      	 <span class="number">4540042</span>	       <span class="number">251.5</span> ns/op	   <span class="number">4085982</span> reads	    <span class="number">454060</span> writes	       <span class="number">8</span> B/op	       <span class="number">0</span> allocs/op</span><br><span class="line">BenchmarkCompare/SyncMap_1000000_Write10%<span class="number">-12</span>    	 <span class="number">5497419</span>	       <span class="number">314.2</span> ns/op	   <span class="number">4947626</span> reads	    <span class="number">549793</span> writes	      <span class="number">47</span> B/op	       <span class="number">1</span> allocs/op</span><br><span class="line">BenchmarkCompare/RWMap_1000000_Write50%<span class="number">-12</span>      	 <span class="number">3618709</span>	       <span class="number">344.2</span> ns/op	   <span class="number">1809258</span> reads	   <span class="number">1809451</span> writes	      <span class="number">12</span> B/op	       <span class="number">1</span> allocs/op</span><br><span class="line">BenchmarkCompare/SyncMap_1000000_Write50%<span class="number">-12</span>    	 <span class="number">4418014</span>	       <span class="number">353.6</span> ns/op	   <span class="number">2208906</span> reads	   <span class="number">2209108</span> writes	      <span class="number">47</span> B/op	       <span class="number">2</span> allocs/op</span><br><span class="line">BenchmarkCompare/RWMap_1000000_Write90%<span class="number">-12</span>      	 <span class="number">5323965</span>	       <span class="number">266.0</span> ns/op	    <span class="number">532340</span> reads	   <span class="number">4791625</span> writes	      <span class="number">15</span> B/op	       <span class="number">1</span> allocs/op</span><br><span class="line">BenchmarkCompare/SyncMap_1000000_Write90%<span class="number">-12</span>    	 <span class="number">3304040</span>	       <span class="number">446.7</span> ns/op	    <span class="number">330360</span> reads	   <span class="number">2973680</span> writes	      <span class="number">48</span> B/op	       <span class="number">3</span> allocs/o</span><br></pre></td></tr></table></figure><br>在这个数量级下，我们终于看到 <code>sync.Map</code> 的性能均低于 <code>RWMap</code>，这应该是大容量内存的拷贝带来的性能开销，已经超过了锁竞争导致的开销，另一方面，当数量级增加，<code>sync.Map</code> 与 <code>RWMap</code> 由不同机制的带来的性能优势也在被抹平。</p>
<p>另外我也观察到一个奇怪的现象，<code>RWMap</code> 在写比例为 50% 的时候性能最差（同等数量级下）,而在写比例上升到 90% 的时候性能又有所提升。这是因为 <code>RWMap</code> 使用的是读写锁，在读写相当的情况下，共享锁的竞争最激烈，锁状态的频繁变化会拖慢读写性能，而当写比例增加到 90% 的时候，基本都是写操作之间锁的竞争，此时 <code>RWMutex</code> 几乎等同于 <code>Mutex</code>，只需要等待其他写操作释放锁即可，相比之下对性能的影响更小。</p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>通过以上源码分析和性能测试的比较，我们得出结论，在数量级较低的情况下，以本人的 CPU(i7-8850H CPU @ 2.60GH) 为例，当 key 数量达到百万级别时，<code>sync.Map</code> 的读写性能均低于 <code>RWMap</code> ，而在百万数量级别以下，<code>sync.Map</code> 始终占据优势。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/map/" rel="tag"># map</a>
              <a href="/tags/sync/" rel="tag"># sync</a>
              <a href="/tags/RWMutex/" rel="tag"># RWMutex</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/03/31/resolve-conflict-with-grpc-between-etcd-and-protoc/" rel="prev" title="etcdv3 与 protoc-gen-go 对 grpc 依赖的冲突">
      <i class="fa fa-chevron-left"></i> etcdv3 与 protoc-gen-go 对 grpc 依赖的冲突
    </a></div>
      <div class="post-nav-item">
    <a href="/2025/09/24/go-wire-denpendency-inject/" rel="next" title="Go 依赖注入以及 wire 最佳实践">
      Go 依赖注入以及 wire 最佳实践 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#sync-Map-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="nav-number">1.</span> <span class="nav-text">sync.Map 源码分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sync-Map-%E4%B8%8E-map-sync-RWMutex-%E6%80%A7%E8%83%BD%E5%B7%AE%E5%BC%82"><span class="nav-number">2.</span> <span class="nav-text">sync.Map 与 map+sync.RWMutex 性能差异</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%93%E8%AE%BA"><span class="nav-number">3.</span> <span class="nav-text">结论</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Alpha Gao</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">58</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">104</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Alpha Gao</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : true,
      appId      : 'H96xxLo0hzG4azqx9XRPBLGe-gzGzoHsz',
      appKey     : 'NPnxUKfUoUn6iIlWOyvA1WgE',
      placeholder: "Just Say Anything",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : true,
      lang       : 'en' || 'zh-cn',
      path       : location.pathname,
      recordIP   : true,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
