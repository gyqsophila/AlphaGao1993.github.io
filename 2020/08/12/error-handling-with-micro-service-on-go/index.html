<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"alphagao.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"hide","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="前言刚开始接触 Go 的时候，被 Go 这种可以直接返回多个变量的设计惊呆了，而且错误也是作为变量与函数结果一并返回。在此之前接触的都是 Java 或者 Kotlin 这种只有一个返回值的语言，而这两种语言本身的错误处理机制都是在函数签名上抛出一个异常，由方法调用方决定是否要处理该异常。Java 中所有的异常都继承自 java.lang.Throwable 接口，然后又分为 Error 和 Exc">
<meta property="og:type" content="article">
<meta property="og:title" content="微服务环境下 Go 的错误处理体系设计">
<meta property="og:url" content="https://alphagao.com/2020/08/12/error-handling-with-micro-service-on-go/index.html">
<meta property="og:site_name" content="Here&#39;s to Change">
<meta property="og:description" content="前言刚开始接触 Go 的时候，被 Go 这种可以直接返回多个变量的设计惊呆了，而且错误也是作为变量与函数结果一并返回。在此之前接触的都是 Java 或者 Kotlin 这种只有一个返回值的语言，而这两种语言本身的错误处理机制都是在函数签名上抛出一个异常，由方法调用方决定是否要处理该异常。Java 中所有的异常都继承自 java.lang.Throwable 接口，然后又分为 Error 和 Exc">
<meta property="og:locale">
<meta property="article:published_time" content="2020-08-12T04:14:53.000Z">
<meta property="article:modified_time" content="2022-03-31T08:15:08.088Z">
<meta property="article:author" content="Alpha Gao">
<meta property="article:tag" content="error">
<meta property="article:tag" content="GraphQL">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://alphagao.com/2020/08/12/error-handling-with-micro-service-on-go/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-Hans'
  };
</script>

  <title>微服务环境下 Go 的错误处理体系设计 | Here's to Change</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Here's to Change</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">请问你真的有在努力吗 ？</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://alphagao.com/2020/08/12/error-handling-with-micro-service-on-go/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Alpha Gao">
      <meta itemprop="description" content="You will be what you want.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Here's to Change">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          微服务环境下 Go 的错误处理体系设计
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-08-12 12:14:53" itemprop="dateCreated datePublished" datetime="2020-08-12T12:14:53+08:00">2020-08-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-03-31 16:15:08" itemprop="dateModified" datetime="2022-03-31T16:15:08+08:00">2022-03-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Go/" itemprop="url" rel="index"><span itemprop="name">Go</span></a>
                </span>
            </span>

          
            <span id="/2020/08/12/error-handling-with-micro-service-on-go/" class="post-meta-item leancloud_visitors" data-flag-title="微服务环境下 Go 的错误处理体系设计" title="Views">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2020/08/12/error-handling-with-micro-service-on-go/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2020/08/12/error-handling-with-micro-service-on-go/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>刚开始接触 Go 的时候，被 Go 这种可以直接返回多个变量的设计惊呆了，而且错误也是作为变量与函数结果一并返回。在此之前接触的都是 Java 或者 Kotlin 这种只有一个返回值的语言，而这两种语言本身的错误处理机制都是在函数签名上抛出一个异常，由方法调用方决定是否要处理该异常。Java 中所有的异常都继承自 <code>java.lang.Throwable</code> 接口，然后又分为 Error 和 Exception 两个分支，其中 Error 表示不该由程序处理的错误，通常由虚拟机抛出；而 Exception 又继续分为检查异常和不受检查异常。检查异常必须显式处理，否则编译器无法编译通过，不受检查异常就可以选择性是否进行处理。<br><span id="more"></span><br>基本上 Java 中遇到 Error 或者未经捕获的 Exception ，程序肯定会退出了。这种会直接导致程序退出的错误，我们将其定义为<code>不可恢复错误</code>。其他不会导致程序退出的错误（包含被处理的错误），我们将其定义为<code>可恢复错误</code>。换到 Go 语言中，虽然只有 error 一种表示，但其仅代表可恢复异常。因为在 Go 中，即使你不对 error 作任何处理，也不会导致程序异常停止。能够导致程序停止，不可恢复的错误，全部由 panic 表示。当然为了保证系统稳定性，也可以用 recover 在可能出现 panic 的地方进行捕获。</p>
<p>在我看来，对于不可恢复错误也就是 panic 的处理比较简单，因为这代表一种无路可走的情况，能做的就是破罐子破摔，把错误的信息一股脑的抛出、打印和收集，能够作为排错的依据即可。为了确保生产环境系统的稳定性，可以在生产环境开启对 panic 的捕获，但我建议你在非生产环境关闭对 panic 的捕获，这样可以尽早发现和暴露问题，及早修复，降低生产环境事故率。根据环境决定是否捕获 panic 的方式，可以简单地根据环境变量来判断。</p>
<h2 id="可恢复错误的处理"><a href="#可恢复错误的处理" class="headerlink" title="可恢复错误的处理"></a>可恢复错误的处理</h2><p>在前言里我们说过，Go 语言中，即使不对函数返回的 error 作任何处理，也不会导致程序退出，但业务流程受阻是肯定的。函数的调用方可以按照自己的需求和条件，决定接下来的执行逻辑，或中断执行业务，将错误继续返回，或检查自己的执行流程，或者进入备选的流程等。</p>
<p>根据实践，可以将可恢复错误分成这么几类：</p>
<ul>
<li><strong>前置检查失败</strong><ul>
<li>主要指参数未按照约定提供，例如参数不可空校验失败，参数值范围不正确等，这属于调用方的 <strong>bug</strong></li>
</ul>
</li>
<li><strong>程序错误</strong><ul>
<li>例如 <code>req.(sometype)</code> 进行类型转换，程序运行起来后发现转换失败，这属于程序<strong>自身的 bug</strong></li>
</ul>
</li>
<li><strong>依赖服务调用错误</strong><ul>
<li>例如数据库查询时出现了错误，往往都是依赖的某个服务出现了错误，这是最经常处理的错误之一</li>
</ul>
</li>
<li><strong>业务执行错误</strong><ul>
<li>例如在发送验证码时发现发送频率超过了阀值，那么这属于特定业务的错误</li>
</ul>
</li>
</ul>
<p>前两类错误属于开发阶段会出现的错误，换句话说，在开发阶段就应该找出尽可能多的这两类错误，这也是绝大多数我们通常所说的 bug，要极力避免其出现在生产环境。所以对于这两类的错误，最好的处理方式就是显式地抛出，及早修复，具体的抛出方式下面会讲到。</p>
<h3 id="1-错误应该包含的信息"><a href="#1-错误应该包含的信息" class="headerlink" title="1. 错误应该包含的信息"></a>1. 错误应该包含的信息</h3><p>错误最重要的，还是其包含的错误信息，我们要明确的是，错误信息是给人类阅读，更准确得说是给开发者阅读的。所以 Go 语言 error 接口的 <code>Error()</code> 方法直接返回一个表示错误信息的 string。为什么不直接返回一个 string，而是要包装成 error 返回呢？因为如果直接返回了 string，我们该如何识别这是正常的返回值，还是一个错误呢？从这里其实也可以看出，error 在 Go 语言中也只是一个普通的变量，这也是为什么即使不对 error 进行处理，也不会导致程序异常退出的原因。这样做还有一个好处，根据 Go 语言的接口规则，只要实现了 <code>Error()</code> 接口，那么就可以将其作为 error 返回，这提供了方便对 error 进行扩展的途径，我们可以通过自定义结构体来丰富 error 中包含的信息，有助于开发者高效率定位错误源头和原因。</p>
<p>话说回来，Go 语言标准包的 errors 包，仅有一个简单的 <code>New()</code> [^1] 方法。如果只有错误的文本，基本很难定位到出错的位置，尽管可以通过全局搜索的方式来定位，但毕竟信息有限，而且不是所有 error 都是在我们的项目中抛出的，会有很多错误无法定位。因此，我们需要将出错的调用栈信息附加在错误里。调用栈信息对调用方没有意义，也不该将这些信息暴露给调用方，调用方唯一需要关心的是错误的原因和错误类型。调用栈信息对于实现者才是有价值的，因此我们要将错误的文本返回给调用方，同时自身也要收集调用栈信息。这里就要推荐有名的 <a href="https://github.com/pkg/errors">github/pkg/errors</a> 包了，通过 <code>errors.WithStack(err)</code> 或 <code>errors.Wrap(err,&quot;custom message&quot;)</code> 把此时的调用栈信息附加进去，然后在某一个地方统一记录日志，方便开发者快速定位问题。</p>
<p>举个例子：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;github.com/pkg/errors&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// NewUserCtxWithID 开始一个新的聚合根</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewUserCtxWithID</span><span class="params">(userID <span class="type">int32</span>, repo facade.UserRepository)</span></span> (*UserCtx, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> userID &lt;= <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 这里属于前置检查失败，所以直接返回错误文本即可</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">&quot;parameter userID invalid&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	owner, err := repo.GetUserByUserID(userID)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 这里查找用户失败，包裹原错误返回</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errors.Wrapf(err, <span class="string">&quot;user %d not found&quot;</span>,userID)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> &amp;UserCtx&#123;user: ToUserDO(owner), repo: repo&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>因为这里的调用属于同一个系统的内部调用，所以错误的消费方还是开发者，需要暴露出错误栈信息，这无可厚非，但是这些并不足以给调用方提供错误类型的判断依据，这在调用方需要根据不同的错误类型执行不同的分支逻辑的时候尤为重要。因此，需要通过自定义错误类型的方式提供错误判断依据。</p>
<h3 id="2-特定错误类型"><a href="#2-特定错误类型" class="headerlink" title="2. 特定错误类型"></a>2. 特定错误类型</h3><p>上一小节提到， Go 中自定义错误类型非常简单，只需要实现 <code>Error()</code> 方法即可，但这样的做法有点重，我们可以直接通过标准包的 <code>errors.New(msg)</code> 来定义一个错误：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    ErrFeedNotExist = errors.New(<span class="string">&quot;feed not exist&quot;</span>)</span><br><span class="line">    ErrFeedPermisssionDenied = errors.New(<span class="string">&quot;feed permission denied&quot;</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetFeed</span><span class="params">(userID,feedID <span class="type">int32</span>,repo facade.FeedRepositroy)</span></span>(*Feed,<span class="type">error</span>)&#123;</span><br><span class="line">    feed,err := repo.GetFeed(feedID)</span><br><span class="line">    <span class="keyword">if</span> err!=<span class="literal">nil</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, ErrFeedNotExist</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> !checkHasPermission(userID,feed)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, ErrFeedPermissionDenied</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> feed,<span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样当调用方拿到返回值就可以对错误进行判断：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetFeed</span><span class="params">(ctx context.Context, req *feed.GetFeedRequest)</span></span>(*feed.GetFeedResponse, <span class="type">error</span>)&#123;</span><br><span class="line">    feed,err := app.GetFeed(req.GetUserID(),req.GetFeedID())</span><br><span class="line">    <span class="keyword">if</span> err!=<span class="literal">nil</span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> err&#123;</span><br><span class="line">            <span class="keyword">case</span> ErrFeedNotExist:</span><br><span class="line">                <span class="comment">// handle with err</span></span><br><span class="line">            <span class="keyword">case</span> ErrFeedPermisssionDenied:</span><br><span class="line">                <span class="comment">// another logic flow</span></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="comment">// unknow err, return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &amp;feed.GetFeedResponse&#123;</span><br><span class="line">        Feed:feed,</span><br><span class="line">    &#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上这种方式仅限同一个微服务内，甚至限于同一个领域服务的同一个层（针对领域驱动设计），因为不同服务之间序列化会导致信息丢失，不同模块之间会导致产生依赖。虽然有一些第三方包也会采用这种方式来定义特定错误，但这样会明显导致公共库与调用方代码产生依赖，需要慎重考虑是否使用。除了自定义全局 Err 变量，自定义 Error 类型也同样有这个问题。</p>
<p>这样的话问题就来了，不能定义全局错误，自定义错误类型也不好，还能有什么办法判断错误类型吗？有，我们可以判断错误的行为。</p>
<h3 id="3-断言错误的行为"><a href="#3-断言错误的行为" class="headerlink" title="3. 断言错误的行为"></a>3. 断言错误的行为</h3><p>我们可以利用 Go 中的接口来做文章，这里我们通过自定义错误类型 (仅包内可见) 来实现。假定模块 A 依赖于模块 B ，A 需要判断是否因为权限不够导致失败，那么可以先定义一个 A 和 B 都可见的接口：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> c</span><br><span class="line"><span class="keyword">type</span> ErrPermissionDenyed <span class="keyword">interface</span>&#123;</span><br><span class="line">    PermissionDenied()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>然后在 B 中定义结构体 errPermissionDenied:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> b</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> errPermissionDenied <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*errPermissionDinied)</span></span> PermissionDenied()&#123;</span><br><span class="line">    <span class="comment">//nothing</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*errPermissionDenied)</span></span> Error() <span class="type">string</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;permission denied&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetFeed</span><span class="params">(userID,feedID <span class="type">int32</span>,repo facade.FeedRepositroy)</span></span>(*Feed,<span class="type">error</span>)&#123;</span><br><span class="line">    feed,err := repo.GetFeed(feedID)</span><br><span class="line">    <span class="keyword">if</span> !checkHasPermission(userID,feed)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, &amp;ErrFeedPermissionDenied&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> feed,<span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>因为首字母小写，对包外不可见，避免了直接引用导致的依赖。<br>这样只需要在 A 中判断返回的错误是否实现了指定的接口来决定后续的逻辑走向：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetFeed</span><span class="params">(ctx context.Context, req *feed.GetFeedRequest)</span></span>(*feed.GetFeedResponse, <span class="type">error</span>)&#123;</span><br><span class="line">    feed,err := app.GetFeed(req.GetUserID(),req.GetFeedID())</span><br><span class="line">    <span class="keyword">if</span> err!=<span class="literal">nil</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ok:= err.(ErrPermissionDenied)；ok &#123;</span><br><span class="line">                <span class="comment">// another logic flow</span></span><br><span class="line">                <span class="keyword">return</span> ...</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// default err handle</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>,err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &amp;feed.GetFeedResponse&#123;</span><br><span class="line">        Feed:feed,</span><br><span class="line">    &#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样的好处在于，上层不需要引入第三方 package 中的类型就能知道错误的类型，只关心返回的 error 是否实现了特定行为即可。如果要替换第三方 package，只要修改与第三方 package 直接打交道的这一层即可。</p>
<p>但这也仅适用于某一个微服务内，跨服务的场景这种方式就无能为力了。</p>
<h3 id="4-错误码"><a href="#4-错误码" class="headerlink" title="4. 错误码"></a>4. 错误码</h3><p>如果以单个微服务划分边界，上面所讲到的都是边界内的调用，而边界与边界之间最好的错误传递方式应该就是错误码了。客户端调用远程的 Restful 服务就属于边界与边界之间的调用，我们也经常看到错误码的文档。微服务之间当然也可以通过 rest 调用，识别错误码，但更多的是采用 rpc 的方式进行跨边界的调用，尤其 grpc 更是 rpc 框架中的利器，所以我们首选就是通过 grpc 的错误码机制来跨边界传递错误。</p>
<p>与 rest 远程调用返回 </p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span> </span><br><span class="line">    <span class="attr">&quot;code&quot;</span><span class="punctuation">:</span><span class="number">200</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;msg&quot;</span><span class="punctuation">:</span><span class="string">&quot;ok&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>这样的结构不同，grpc 的调用与一般的方法调用并没有差异，也是返回 response, error 两个值，我们当然可以在每一个 response 中都加上 code, msg 两个字段，但是这样不够优雅，也会导致 rpc 接口上的 error 形同虚设，因此还是需要在 error 里做做文章。</p>
<p>rpc 框架因为序列化的关系，不如进程内调用简单直白，为了保证顺利序列化的同时信息不丢失，一般都会将错误信息打包成特定结构，所以我们要借助这个特定结构来传递错误信息。grpc 中 status 就是用于序列化 rpc 错误的特殊结构体。 status 包是对 Google.Golang.org/genproto/Googleapis/rpc/status 下 Status 的引用，其中包含 Code、Message 和 Details 3 个字段，我们可以实现对错误信息的传递。</p>
<p>status 包同时提供了开箱即用的转换的函数：</p>
<ul>
<li><code>func status.FromError(err)(s *Status, ok bool)</code> <ul>
<li>尝试将 error 转换为 Status 结构体，从而获取错误码和 message</li>
</ul>
</li>
<li><code>func status.Error(c codes.Code,msg string) error</code><ul>
<li>直接将 code 和 msg 打包成 error </li>
</ul>
</li>
</ul>
<p>有了以上两个函数，可以轻松地在微服务之间传递错误详情，服务提供方通过 <code>Error()</code> 函数打包 error，服务调用方通过 <code>FromError()</code> 解析 error。</p>
<h3 id="5-网关服务的处理"><a href="#5-网关服务的处理" class="headerlink" title="5. 网关服务的处理"></a>5. 网关服务的处理</h3><p>我们的业务使用 GraphQL 作为业务网关，因此错误的返回需要能够匹配 GraphQL 的固定格式。GraphQL 的接口固定响应格式为：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;errors&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;message&quot;</span><span class="punctuation">:</span><span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;path&quot;</span><span class="punctuation">:</span><span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;extensions&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>errors 下面的 extensions  是一个可自定义的 json 对象，通常的做法是把错误码放进 extensions 中，作为客户端判断错误码类型的依据。</p>
<p>看个例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *AccountServer)</span></span> CreateGroup(ctx context.Context, in *account.CreateGroupRequest) (*account.GetGroupResponse, <span class="type">error</span>) &#123;</span><br><span class="line">    cateGory := factory.ToCateGoryDO(in.CateGory)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(in.GetRoleName())==<span class="number">0</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>,errs.GenRPCErr(code.Code_INVALID_ROLE_NAME)</span><br><span class="line">    &#125;</span><br><span class="line">	groupDO, err := appSrv.CreateGroup(...)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> &amp;account.GetGroupResponse&#123;</span><br><span class="line">		Group: factory.ToGroupDTO(groupDO),</span><br><span class="line">	&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面是服务 F 的某一段程序，在检查传入的 roleName 不符合要求时，返回一个带有错误码错误，这里实际上就是一个 status 结构体，然后会通过 grpc 传输到网关服务 G :</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *mutationResolver)</span></span> CreateGroup(ctx context.Context, input generated.CreateGroupInput) (*accDO.Group, <span class="type">error</span>) &#123;</span><br><span class="line">	userID := ctx.Value(common.KeyUserID).(<span class="type">int32</span>)</span><br><span class="line">    group,err := service.Account.CreateGroup(userID, input)</span><br><span class="line">    <span class="keyword">if</span> err!=<span class="literal">nil</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> status,ok := status.FromError(err);ok &#123;</span><br><span class="line">            graphql.AddError(ctx, &amp;gqlerror.Error&#123;</span><br><span class="line">		        Message: status.Message(),</span><br><span class="line">		        Extensions: <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;</span><br><span class="line">			        <span class="string">&quot;code&quot;</span>: <span class="type">uint32</span>(status.Code()),</span><br><span class="line">		        &#125;,</span><br><span class="line">            &#125;)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>,<span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>,err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> group,<span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这段程序是 graphql 网关服务的某一个接口对错误的处理，我们首先会判断错误是否为 status 结构体，并将该结构体解析为适合 graphql 的错误形式返回，否则正常返回。</p>
<p>这个流程虽然没有问题，但是在每个 graphql 接口都要这么写也太麻烦了，看下 gqlgen 的文档，发现可以统一对 graphql 接受到的错误进行处理，类似于拦截器：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HandleGraphErr 统一转换错误为适配 graphql 的 error</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HandleGraphErr</span><span class="params">(ctx context.Context, err <span class="type">error</span>)</span></span> *gqlerror.Error &#123;</span><br><span class="line">	<span class="keyword">if</span> status, ok := status.FromError(err); ok &#123;</span><br><span class="line">		<span class="keyword">return</span> &amp;gqlerror.Error&#123;</span><br><span class="line">			Path:    graphql.GetFieldContext(ctx).Path(),</span><br><span class="line">			Message: status.Message(),</span><br><span class="line">			Extensions: <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;</span><br><span class="line">				<span class="string">&quot;code&quot;</span>: <span class="type">uint32</span>(status.Code()),</span><br><span class="line">			&#125;,</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> graphql.DefaultErrorPresenter(ctx, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这段程序的作用是统一处理接受到的错误，优先识别 status 结构体错误，然后包装为适合 graphql 的错误，否则使用默认的错误处理直接返回。</p>
<p>然后在启动 graphql 服务的时候把这个处理函数设置一下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PrivateGraphqlHandler</span><span class="params">()</span></span> gin.HandlerFunc &#123;</span><br><span class="line">	<span class="keyword">defer</span> common.Catch()</span><br><span class="line"></span><br><span class="line">	h := handler.NewDefaultServer(</span><br><span class="line">		privateGraphGenerated.NewExecutableSchema(</span><br><span class="line">			privateGraphGenerated.Config&#123;Resolvers: &amp;privateGraph.Resolver&#123;&#125;&#125;))</span><br><span class="line"></span><br><span class="line">	h.SetErrorPresenter(<span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, err <span class="type">error</span>)</span></span> *gqlerror.Error &#123;</span><br><span class="line">		<span class="keyword">return</span> errs.HandleGraphErr(ctx, err)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">		h.ServeHTTP(c.Writer, c.Request)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在具体的 graphql 接口上就非常简单了：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *mutationResolver)</span></span> CreateGroup(ctx context.Context, input generated.CreateGroupInput) (*accDO.Group, <span class="type">error</span>) &#123;</span><br><span class="line">	userID := ctx.Value(common.KeyUserID).(<span class="type">int32</span>)</span><br><span class="line">	<span class="keyword">return</span> service.Account.CreateGroup(userID, input)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当出现这个错误的时候，客户端就会得到如下错误信息：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;errors&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="string">&quot;INVALID_ROLENAME&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;path&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;createGroup&quot;</span></span><br><span class="line">      <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;extensions&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;code&quot;</span><span class="punctuation">:</span> <span class="number">110103</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="6-对用户友好的错误提示"><a href="#6-对用户友好的错误提示" class="headerlink" title="6. 对用户友好的错误提示"></a>6. 对用户友好的错误提示</h3><p>在上面的错误码中，我们定义了很多错误，但是这些错误在返回到客户端的时候，仍然是开发者视角的错误信息。不管是错误码还是 “INVALID_ROLENAME” 这样的错误提示，对于用户都不够友好。客户端的错误提示要让用户能够理解，还需要隐藏一些用户不必知道的信息，同时考虑到针对同一个错误的提示内容和模版都有改变的可能，因此需要一个统一的文案配置系统，针对每个错误码进行翻译，甚至可以保留多个语言的翻译版本，对于国际化应用也能够方便一些。最简单的方式我觉得还是依托于 proto 错误码文件进行翻译，然后直接根据语言、错误码查找对应的提示内容即可。</p>
<p>不过除了生产环境，别的环境的应用都是我们开发自己在使用，所以有时候暴露一些调试信息能够加快定位问题的速度，所以我建议客户端在非生产环境也可以把报错信息完整打印出来到用户界面，通常都可以通过 logLevel 或环境变量来实现，不再赘述。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在微服务开发大行其道的当下，一个错误从产生到被消费，会经过很多系统（服务），如果没有合理得对错误进行处理，会大大得增加各个系统之间沟通、调试的成本。很多像我一样刚进入服务端开发领域的小白，都会一股脑地将 error 直接返回，将业务错误、运行时错误、程序错误当成同样的 error 来处理，主要还是没有经历过在代码的海洋中艰难 debug 的窘态。一个设计良好的错误处理机制，不仅能够清晰展现系统内部错误发生的链路，加快 debug 速度，同时还能促进系统设计的合理性和可用性。</p>
<p>这篇文章虽然是基于 Go 语言，但实际上很多想法和思考都可以使用于其他大部分语言，也希望这些想法对你能有所启发。</p>
<h2 id="注脚"><a href="#注脚" class="headerlink" title="注脚"></a>注脚</h2><p>[^1]: 截止本文发布时间(2020-08-14)，Go 版本 1.14.2，errors 包中已经新增加了 <code>UnWrap</code>、<code>As</code>、<code>Is</code> 等方法；</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote>
<ol>
<li><a href="https://juejin.im/post/6844904111813427214">微服务错误处理的一些思考</a></li>
<li><a href="https://www.ituring.com.cn/article/508191">如何优雅的在 Golang 中进行错误处理</a></li>
<li><a href="https://github.com/99designs/gqlgen/blob/master/docs/content/reference/errors.md">99designs/gqlgen</a></li>
<li><a href="https://github.com/pkg/errors">pkg/errors</a></li>
</ol>
</blockquote>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/error/" rel="tag"># error</a>
              <a href="/tags/GraphQL/" rel="tag"># GraphQL</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/04/18/config-go-lint-in-goland/" rel="prev" title="Mac 中为 GoLand 中配置 golint">
      <i class="fa fa-chevron-left"></i> Mac 中为 GoLand 中配置 golint
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/03/31/resolve-conflict-with-grpc-between-etcd-and-protoc/" rel="next" title="etcdv3 与 protoc-gen-go 对 grpc 依赖的冲突">
      etcdv3 与 protoc-gen-go 对 grpc 依赖的冲突 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%AF%E6%81%A2%E5%A4%8D%E9%94%99%E8%AF%AF%E7%9A%84%E5%A4%84%E7%90%86"><span class="nav-number">2.</span> <span class="nav-text">可恢复错误的处理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E9%94%99%E8%AF%AF%E5%BA%94%E8%AF%A5%E5%8C%85%E5%90%AB%E7%9A%84%E4%BF%A1%E6%81%AF"><span class="nav-number">2.1.</span> <span class="nav-text">1. 错误应该包含的信息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E7%89%B9%E5%AE%9A%E9%94%99%E8%AF%AF%E7%B1%BB%E5%9E%8B"><span class="nav-number">2.2.</span> <span class="nav-text">2. 特定错误类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E6%96%AD%E8%A8%80%E9%94%99%E8%AF%AF%E7%9A%84%E8%A1%8C%E4%B8%BA"><span class="nav-number">2.3.</span> <span class="nav-text">3. 断言错误的行为</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E9%94%99%E8%AF%AF%E7%A0%81"><span class="nav-number">2.4.</span> <span class="nav-text">4. 错误码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E7%BD%91%E5%85%B3%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%A4%84%E7%90%86"><span class="nav-number">2.5.</span> <span class="nav-text">5. 网关服务的处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-%E5%AF%B9%E7%94%A8%E6%88%B7%E5%8F%8B%E5%A5%BD%E7%9A%84%E9%94%99%E8%AF%AF%E6%8F%90%E7%A4%BA"><span class="nav-number">2.6.</span> <span class="nav-text">6. 对用户友好的错误提示</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">3.</span> <span class="nav-text">总结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B3%A8%E8%84%9A"><span class="nav-number">4.</span> <span class="nav-text">注脚</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E8%80%83"><span class="nav-number">5.</span> <span class="nav-text">参考</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Alpha Gao</p>
  <div class="site-description" itemprop="description">You will be what you want.</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">56</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">categories</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">100</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Alpha Gao</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : true,
      appId      : 'H96xxLo0hzG4azqx9XRPBLGe-gzGzoHsz',
      appKey     : 'NPnxUKfUoUn6iIlWOyvA1WgE',
      placeholder: "Just Say Anything",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : true,
      lang       : 'en' || 'zh-cn',
      path       : location.pathname,
      recordIP   : true,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
